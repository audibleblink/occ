#!/usr/bin/env bash
set -euo pipefail

# occ - OpenCode Container
# Launches ephemeral Tailscale-connected dev containers

# ============================================================================
# Configuration
# ============================================================================

IMAGE_NAME="occ-workspace:latest"
CONFIG_DIR="${HOME}/.config/occ"
OPENCODE_CONFIG_DIR="${HOME}/.config/opencode"

# Default allowlist of environment variables to pass through
ENV_ALLOWLIST=(
  TS_AUTHKEY
  LANG
  LC_ALL
  LC_CTYPE
  EDITOR
  TERM
  ANTHROPIC_API_KEY
  OPENAI_API_KEY
  OPENROUTER_API_KEY
  AWS_ACCESS_KEY_ID
  AWS_SECRET_ACCESS_KEY
  AWS_SESSION_TOKEN
  GITHUB_TOKEN
  GH_TOKEN
)

# ============================================================================
# Usage / Help
# ============================================================================

usage() {
  cat <<'EOF'
occ - OpenCode Container

Usage:
  occ [OPTIONS] [PROJECT_PATH]

Arguments:
  PROJECT_PATH    Path to project directory (mounted at /workspace)

Options:
  --rebuild       Force rebuild of the container image
  --env VAR       Pass additional environment variable (repeatable)
  --no-tailscale  Skip Tailscale setup in the container
  --help          Print this help message

Subcommands:
  occ status      List running occ containers
  occ config      Show config directory

Examples:
  occ                         Start bash in container
  occ ~/Code/project          Start OpenCode in project
  occ --rebuild               Rebuild container image
  occ --env MY_VAR ~/proj     Pass additional env var
  occ --no-tailscale          Run without Tailscale
EOF
}

# ============================================================================
# Runtime Detection
# ============================================================================

RUNTIME=""

detect_runtime() {
  # 1. Check OCC_RUNTIME env var first
  if [[ -n "${OCC_RUNTIME:-}" ]]; then
    if command -v "$OCC_RUNTIME" &>/dev/null; then
      RUNTIME="$OCC_RUNTIME"
      return 0
    else
      echo "Error: OCC_RUNTIME='$OCC_RUNTIME' is set but not found in PATH" >&2
      exit 1
    fi
  fi

  # 2. Check for Apple 'container' binary
  if command -v container &>/dev/null; then
    RUNTIME="container"
    return 0
  fi

  # 3. Fall back to docker
  if command -v docker &>/dev/null; then
    RUNTIME="docker"
    return 0
  fi

  # 4. Error if neither found
  echo "Error: No container runtime found. Install Docker or the Apple 'container' CLI." >&2
  echo "Alternatively, set OCC_RUNTIME to specify a runtime." >&2
  exit 1
}

# ============================================================================
# Runtime Abstraction Helpers
# ============================================================================

# rt_build - Build an image
# Args: $1 = tag name, $2 = context directory
rt_build() {
  local tag="$1"
  local context="$2"
  local nocache="${3:-}"

  if [[ "$RUNTIME" == "container" ]]; then
    if [[ "$nocache" == "--no-cache" ]]; then
      container build --no-cache --tag "$tag" "$context"
    else
      container build --tag "$tag" "$context"
    fi
  else
    if [[ "$nocache" == "--no-cache" ]]; then
      docker build --no-cache -t "$tag" "$context"
    else
      docker build -t "$tag" "$context"
    fi
  fi
}

# rt_run - Run a container
# Args: $@ = all arguments to pass to run command
rt_run() {
  if [[ "$RUNTIME" == "container" ]]; then
    container run --rm -it "$@"
  else
    docker run --rm -it "$@"
  fi
}

# rt_mount - Format mount argument
# Args: $1 = source, $2 = destination, $3 = "readonly" for read-only mount (optional)
rt_mount() {
  local src="$1"
  local dst="$2"
  local readonly_flag="${3:-}"

  if [[ "$RUNTIME" == "container" ]]; then
    # Apple container CLI uses: --mount type=bind,src=X,dst=Y,readonly
    if [[ "$readonly_flag" == "readonly" ]]; then
      echo "--mount type=bind,src=$src,dst=$dst,readonly"
    else
      echo "--mount type=bind,src=$src,dst=$dst"
    fi
  else
    # Docker uses: -v src:dst:ro
    if [[ "$readonly_flag" == "readonly" ]]; then
      echo "-v $src:$dst:ro"
    else
      echo "-v $src:$dst"
    fi
  fi
}

# rt_list - List containers
# Args: $@ = optional filter args
rt_list() {
  if [[ "$RUNTIME" == "container" ]]; then
    container list "$@"
  else
    docker ps "$@"
  fi
}

# rt_rmi - Remove an image
# Args: $1 = image name
rt_rmi() {
  local image="$1"

  if [[ "$RUNTIME" == "container" ]]; then
    container image remove "$image"
  else
    docker rmi "$image"
  fi
}

# rt_image_exists - Check if an image exists
# Args: $1 = image name
rt_image_exists() {
  local image="$1"

  if [[ "$RUNTIME" == "container" ]]; then
    container image list 2>/dev/null | grep -q "$image" && return 0
    return 1
  else
    docker image inspect "$image" &>/dev/null && return 0
    return 1
  fi
}

# ============================================================================
# Environment Variable Handling
# ============================================================================

# Associative array to collect environment variables (KEY=VALUE format)
# Using associative array allows later values to override earlier ones
declare -A ENV_MAP

# collect_allowlist_envs - Collect env vars from the allowlist that are set on host
collect_allowlist_envs() {
  for var in "${ENV_ALLOWLIST[@]}"; do
    if [[ -n "${!var:-}" ]]; then
      ENV_MAP["$var"]="${!var}"
    fi
  done
}

# collect_env_flags - Collect env vars from --env flags
# Args: array of variable names passed via --env
collect_env_flags() {
  local -a vars=("$@")
  for var in "${vars[@]}"; do
    if [[ -n "${!var:-}" ]]; then
      ENV_MAP["$var"]="${!var}"
    fi
    # Silently skip if unset (per spec)
  done
}

# parse_dotenv - Parse a .env file and add to ENV_MAP
# Args: $1 = filepath to .env file
parse_dotenv() {
  local filepath="$1"
  
  if [[ ! -f "$filepath" ]]; then
    return 0
  fi
  
  local line_num=0
  while IFS= read -r line || [[ -n "$line" ]]; do
    line_num=$((line_num + 1))
    
    # Skip blank lines
    if [[ -z "$line" ]]; then
      continue
    fi
    
    # Skip comments
    if [[ "$line" =~ ^[[:space:]]*# ]]; then
      continue
    fi
    
    # Parse KEY=VALUE (no shell expansion, no multiline)
    if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"
      ENV_MAP["$key"]="$value"
    else
      echo "Warning: Malformed line $line_num in $filepath, skipping: $line" >&2
    fi
  done < "$filepath"
}

# inject_implicit_vars - Add implicit vars (HOST_UID, HOST_GID, NO_TAILSCALE)
# Args: $1 = true/false for no_tailscale flag
inject_implicit_vars() {
  local no_tailscale="$1"
  
  # Always inject HOST_UID and HOST_GID
  ENV_MAP["HOST_UID"]="$(id -u)"
  ENV_MAP["HOST_GID"]="$(id -g)"
  
  # Inject NO_TAILSCALE=1 when --no-tailscale is passed
  if [[ "$no_tailscale" == true ]]; then
    ENV_MAP["NO_TAILSCALE"]="1"
  fi
}

# build_env_array - Build the final array of -e KEY=VALUE flags for container runtime
# Returns the array via stdout, one flag per line
build_env_array() {
  local -a env_flags=()
  
  for key in "${!ENV_MAP[@]}"; do
    env_flags+=("-e" "${key}=${ENV_MAP[$key]}")
  done
  
  # Output each element
  for flag in "${env_flags[@]}"; do
    echo "$flag"
  done
}

# debug_print_env - Print env vars when OCC_DEBUG=1
debug_print_env() {
  if [[ "${OCC_DEBUG:-}" == "1" ]]; then
    echo "=== Environment Variables ===" >&2
    for key in $(echo "${!ENV_MAP[@]}" | tr ' ' '\n' | sort); do
      echo "  ${key}=${ENV_MAP[$key]}" >&2
    done
    echo "=============================" >&2
  fi
}

# ============================================================================
# Image Management
# ============================================================================

# ensure_image - Build or verify the occ-workspace image exists
# Args: $1 = "true" if --rebuild was passed
ensure_image() {
  local rebuild="$1"
  local dockerfile_path="$CONFIG_DIR/Dockerfile"
  
  # Check if Dockerfile exists
  if [[ ! -f "$dockerfile_path" ]]; then
    echo "Error: Dockerfile not found at $dockerfile_path" >&2
    echo "Please run 'install.sh' first or create the Dockerfile manually." >&2
    exit 1
  fi
  
  # Check if image exists (unless --rebuild forces a build)
  local needs_build=false
  
  if [[ "$rebuild" == "true" ]]; then
    echo "Rebuild requested, forcing image build..."
    needs_build=true
  elif ! rt_image_exists "$IMAGE_NAME"; then
    echo "Image $IMAGE_NAME not found, building..."
    needs_build=true
  fi
  
  if [[ "$needs_build" == "true" ]]; then
    echo "Building image $IMAGE_NAME from $CONFIG_DIR..."
    echo ""
    
    local nocache_flag=""
    if [[ "$rebuild" == "true" ]]; then
      nocache_flag="--no-cache"
    fi
    
    # Build the image (streams output to terminal)
    if ! rt_build "$IMAGE_NAME" "$CONFIG_DIR" "$nocache_flag"; then
      echo "" >&2
      echo "Error: Image build failed!" >&2
      echo "Check the build output above for details." >&2
      exit 1
    fi
    
    echo ""
    echo "Image $IMAGE_NAME built successfully."
  fi
}

# ============================================================================
# Container Launch
# ============================================================================

# launch_container - Start the container with appropriate mounts and env vars
# Args: $1 = project_path (can be empty)
launch_container() {
  local project_path="$1"
  
  # Generate unique container name
  local container_name="occ-workspace-$(date +%Y%m%d-%H%M%S)"
  
  # Build the run command arguments
  local -a run_args=()
  run_args+=("--name" "$container_name")
  
  # Add environment variables
  local -a env_flags
  mapfile -t env_flags < <(build_env_array)
  run_args+=("${env_flags[@]}")
  
  # Mount opencode config (readonly)
  local opencode_mount
  opencode_mount=$(rt_mount "$OPENCODE_CONFIG_DIR" "/home/user/.config/opencode" "readonly")
  # Split the mount string into args (handles both -v and --mount formats)
  read -ra mount_args <<< "$opencode_mount"
  run_args+=("${mount_args[@]}")
  
  # If project path provided, mount it and set working dir
  if [[ -n "$project_path" ]]; then
    local project_mount
    project_mount=$(rt_mount "$project_path" "/workspace")
    read -ra project_mount_args <<< "$project_mount"
    run_args+=("${project_mount_args[@]}")
    run_args+=("-w" "/workspace")
  fi
  
  # Add the image name
  run_args+=("$IMAGE_NAME")
  
  # Add the command
  if [[ -n "$project_path" ]]; then
    run_args+=("opencode")
  else
    run_args+=("/bin/bash")
  fi
  
  # Debug output
  if [[ "${OCC_DEBUG:-}" == "1" ]]; then
    echo "=== Container Launch ===" >&2
    echo "  Name: $container_name" >&2
    echo "  Runtime: $RUNTIME" >&2
    echo "  Project: ${project_path:-<none>}" >&2
    echo "  Command: ${run_args[*]}" >&2
    echo "========================" >&2
  fi
  
  # Launch the container
  rt_run "${run_args[@]}"
}

# ============================================================================
# Subcommands
# ============================================================================

cmd_status() {
  detect_runtime
  echo "Running occ containers (runtime: $RUNTIME):"
  echo ""
  
  if [[ "$RUNTIME" == "container" ]]; then
    # Apple container CLI - filter manually
    local output
    output=$(container list 2>/dev/null || true)
    if [[ -n "$output" ]]; then
      # Print header if there's output
      echo "$output" | head -1
      echo "$output" | grep "occ-workspace-" || echo "(no occ containers running)"
    else
      echo "(no containers running)"
    fi
  else
    # Docker - use filter
    local output
    output=$(docker ps --filter "name=occ-workspace-" --format "table {{.Names}}\t{{.Status}}\t{{.Mounts}}" 2>/dev/null || true)
    if [[ -n "$output" && $(echo "$output" | wc -l) -gt 1 ]]; then
      echo "$output"
    else
      echo "(no occ containers running)"
    fi
  fi
  exit 0
}

cmd_config() {
  echo "OCC config directory: $CONFIG_DIR"
  echo ""
  
  if [[ -d "$CONFIG_DIR" ]]; then
    echo "Contents:"
    ls -la "$CONFIG_DIR" 2>/dev/null || echo "(empty)"
    echo ""
    
    # Offer to open in editor
    if [[ -n "${EDITOR:-}" ]]; then
      echo "To edit configuration:"
      echo "  $EDITOR $CONFIG_DIR"
    else
      echo "Tip: Set \$EDITOR to quickly open the config directory."
    fi
  else
    echo "(directory does not exist yet)"
    echo ""
    echo "Run 'install.sh' to create the config directory with default files."
  fi
  exit 0
}

# ============================================================================
# Validation
# ============================================================================

validate_project_path() {
  local path="$1"
  
  if [[ ! -e "$path" ]]; then
    echo "Error: Project path does not exist: $path" >&2
    exit 1
  fi
  
  if [[ ! -d "$path" ]]; then
    echo "Error: Project path is not a directory: $path" >&2
    exit 1
  fi
}

validate_opencode_config() {
  if [[ ! -d "$OPENCODE_CONFIG_DIR" ]]; then
    echo "Error: OpenCode config directory not found: $OPENCODE_CONFIG_DIR" >&2
    echo "Please ensure OpenCode is installed and configured first." >&2
    exit 1
  fi
}

# ============================================================================
# Main
# ============================================================================

main() {
  # Parse arguments
  local rebuild=false
  local no_tailscale=false
  local project_path=""
  local -a env_vars=()
  local show_help=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help)
        show_help=true
        shift
        ;;
      --rebuild)
        rebuild=true
        shift
        ;;
      --no-tailscale)
        no_tailscale=true
        shift
        ;;
      --env)
        if [[ $# -lt 2 ]]; then
          echo "Error: --env requires a variable name" >&2
          exit 1
        fi
        env_vars+=("$2")
        shift 2
        ;;
      status)
        cmd_status
        ;;
      config)
        cmd_config
        ;;
      -*)
        echo "Error: Unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
      *)
        # Positional argument - project path
        if [[ -z "$project_path" ]]; then
          project_path="$1"
        else
          echo "Error: Multiple project paths specified" >&2
          exit 1
        fi
        shift
        ;;
    esac
  done

  # Show help if requested (can be combined with other flags for parsing test)
  if [[ "$show_help" == true ]]; then
    usage
    exit 0
  fi

  # Detect runtime
  detect_runtime

  # Validate opencode config exists
  validate_opencode_config

  # Validate project path if provided
  if [[ -n "$project_path" ]]; then
    validate_project_path "$project_path"
    # Convert to absolute path
    project_path="$(cd "$project_path" && pwd)"
  fi

  # ============================================================================
  # Collect Environment Variables
  # ============================================================================
  
  # Precedence order (later overrides earlier):
  # 1. allowlist (lowest)
  # 2. --env flags
  # 3. .env file values
  # 4. implicit vars like HOST_UID, HOST_GID, NO_TAILSCALE (highest)
  
  # 1. Collect from allowlist
  collect_allowlist_envs
  
  # 2. Collect from --env flags
  if [[ ${#env_vars[@]} -gt 0 ]]; then
    collect_env_flags "${env_vars[@]}"
  fi
  
  # 3. Parse .env file from project path (if project path is set)
  if [[ -n "$project_path" ]]; then
    parse_dotenv "$project_path/.env"
  fi
  
  # 4. Inject implicit vars (highest precedence)
  inject_implicit_vars "$no_tailscale"
  
  # Debug print if requested
  debug_print_env
  
  # ============================================================================
  # Build/Launch Container
  # ============================================================================
  
  # Ensure the image is built
  ensure_image "$rebuild"
  
  # Launch the container
  launch_container "$project_path"
}

main "$@"
